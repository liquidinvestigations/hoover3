/*
 * SeekStorm REST API documentation
 *
 * Search engine library & multi-tenancy server
 *
 * The version of the OpenAPI document: 0.12.11
 * Contact: wolf.garbe@seekstorm.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for typed errors of method [`create_apikey_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateApikeyApiError {
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_apikey_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteApikeyApiError {
    Status401(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_apikey_indices_info_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetApikeyIndicesInfoApiError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Creates an API key and returns the Base64 encoded API key. Expects the Base64 encoded master API key in the header. Use the master API key displayed in the server console at startup.  WARNING: make sure to set the MASTER_KEY_SECRET environment variable to a secret, otherwise your generated API keys will be compromised.  For development purposes you may also use the SeekStorm server console command 'create' to create an demo API key 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA='.
pub async fn create_apikey_api(
    configuration: &configuration::Configuration,
    apikey: &str,
    create_apikey_api_request: models::CreateApikeyApiRequest,
) -> Result<String, Error<CreateApikeyApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;
    let p_create_apikey_api_request = create_apikey_api_request;

    let uri_str = format!("{}/api/v1/apikey", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", p_apikey.to_string());
    req_builder = req_builder.json(&p_create_apikey_api_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        // Bad API generator! YML said text/plain, the generated code does json
        // serde_json::from_str(&content).map_err(Error::from)
        Ok(content)
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateApikeyApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Deletes an API and returns the number of remaining API keys. Expects the Base64 encoded master API key in the header.  WARNING: This will delete all indices and documents associated with the API key.
pub async fn delete_apikey_api(
    configuration: &configuration::Configuration,
    apikey_master: &str,
    apikey_to_delete: &str,
) -> Result<i64, Error<DeleteApikeyApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions

    let uri_str = format!("{}/api/v1/apikey", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", apikey_master);
    req_builder = req_builder.body(
        serde_json::json!({
            "apikey_base64": apikey_to_delete,
        })
        .to_string(),
    );

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteApikeyApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get info about all indices associated with the specified API key
pub async fn get_apikey_indices_info_api(
    configuration: &configuration::Configuration,
    apikey: &str,
) -> Result<Vec<models::IndexResponseObject>, Error<GetApikeyIndicesInfoApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;

    let uri_str = format!("{}/api/v1/apikey", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", p_apikey.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetApikeyIndicesInfoApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
