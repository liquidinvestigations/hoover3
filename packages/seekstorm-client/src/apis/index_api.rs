/*
 * SeekStorm REST API documentation
 *
 * Search engine library & multi-tenancy server
 *
 * The version of the OpenAPI document: 0.12.11
 * Contact: wolf.garbe@seekstorm.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for typed errors of method [`commit_index_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CommitIndexApiError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_index_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateIndexApiError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_index_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteIndexApiError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_index_info_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetIndexInfoApiError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Commit moves indexed documents from the intermediate uncompressed data structure (array lists/HashMap, queryable by realtime search) in RAM to the final compressed data structure (roaring bitmap) on Mmap or disk - which is persistent, more compact, with lower query latency and allows search with realtime=false. Commit is invoked automatically each time 64K documents are newly indexed as well as on close_index (e.g. server quit). There is no way to prevent this automatic commit by not manually invoking it. But commit can also be invoked manually at any time at any number of newly indexed documents. commit is a **hard commit** for persistence on disk. A **soft commit** for searchability is invoked implicitly with every index_doc, i.e. the document can immediately searched and included in the search results if it matches the query AND the query paramter realtime=true is enabled.  **Use commit with caution, as it is an expensive operation**. **Usually, there is no need to invoke it manually**, as it is invoked automatically every 64k documents and when the index is closed with close_index. Before terminating the program, always call close_index (commit), otherwise all documents indexed since last (manual or automatic) commit are lost. There are only 2 reasons that justify a manual commit: 1. if you want to search newly indexed documents without using realtime=true for search performance reasons or 2. if after indexing new documents there won't be more documents indexed (for some time),    so there won't be (soon) a commit invoked automatically at the next 64k threshold or close_index,    but you still need immediate persistence guarantees on disk to protect against data loss in the event of a crash.
pub async fn commit_index_api(
    configuration: &configuration::Configuration,
    apikey: &str,
    index_id: i64,
) -> Result<i64, Error<CommitIndexApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;
    let p_index_id = index_id;

    let uri_str = format!(
        "{}/api/v1/index/{index_id}",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", p_apikey.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CommitIndexApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create an index within the directory associated with the specified API key and return the index_id.
pub async fn create_index_api(
    configuration: &configuration::Configuration,
    apikey: &str,
    create_index_api_request: models::CreateIndexApiRequest,
) -> Result<i64, Error<CreateIndexApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;
    let p_create_index_api_request = create_index_api_request;

    let uri_str = format!("{}/api/v1/index", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", p_apikey.to_string());
    req_builder = req_builder.json(&p_create_index_api_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateIndexApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete an index within the directory associated with the specified API key and return the number of remaining indices.
pub async fn delete_index_api(
    configuration: &configuration::Configuration,
    apikey: &str,
    index_id: i64,
) -> Result<i64, Error<DeleteIndexApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;
    let p_index_id = index_id;

    let uri_str = format!(
        "{}/api/v1/index/{index_id}",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", p_apikey.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteIndexApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get index Info from index with index_id
pub async fn get_index_info_api(
    configuration: &configuration::Configuration,
    apikey: &str,
    index_id: i64,
) -> Result<models::IndexResponseObject, Error<GetIndexInfoApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;
    let p_index_id = index_id;

    let uri_str = format!(
        "{}/api/v1/index/{index_id}",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", p_apikey.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetIndexInfoApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
