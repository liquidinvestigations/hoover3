/*
 * SeekStorm REST API documentation
 *
 * Search engine library & multi-tenancy server
 *
 * The version of the OpenAPI document: 0.12.11
 * Contact: wolf.garbe@seekstorm.com
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{Deserialize, Serialize};

/// struct for typed errors of method [`delete_document_by_object_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentByObjectApiError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_document_by_parameter_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentByParameterApiError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentApiError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`index_document_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexDocumentApiError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_document_api`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentApiError {
    Status400(),
    Status401(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// Delete document by document_id, by array of document_id (bulk), by query (SearchRequestObject) from index with index_id, or clear all documents from index.  Immediately effective, indpendent of commit. Index space used by deleted documents is not reclaimed (until compaction is implemented), but result_count_total is updated. By manually deleting the delete.bin file the deleted documents can be recovered (until compaction).  Deleted documents impact performance, especially but not limited to counting (Count, TopKCount). They also increase the size of the index (until compaction is implemented). For minimal query latency delete index and reindexing documents is preferred over deleting documents (until compaction is implemented). BM25 scores are not updated (until compaction is implemented), but the impact is minimal.  Document ID can by obtained by search. When deleting by query (SearchRequestObject), it is advised to perform a dry run search first, to see which documents will be deleted.
pub async fn delete_document_by_object_api(
    configuration: &configuration::Configuration,
    apikey: &str,
    index_id: i64,
    search_request_object: models::SearchRequestObject,
) -> Result<i32, Error<DeleteDocumentByObjectApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;
    let p_index_id = index_id;
    let p_search_request_object = search_request_object;

    let uri_str = format!(
        "{}/api/v1/index/{index_id}/doc",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", p_apikey.to_string());
    req_builder = req_builder.json(&p_search_request_object);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDocumentByObjectApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Delete document by document_id from index with index_id  Document ID can by obtained by search. Immediately effective, indpendent of commit. Index space used by deleted documents is not reclaimed (until compaction is implemented), but result_count_total is updated. By manually deleting the delete.bin file the deleted documents can be recovered (until compaction).  Deleted documents impact performance, especially but not limited to counting (Count, TopKCount). They also increase the size of the index (until compaction is implemented). For minimal query latency delete index and reindexing documents is preferred over deleting documents (until compaction is implemented). BM25 scores are not updated (until compaction is implemented), but the impact is minimal.
pub async fn delete_document_by_parameter_api(
    configuration: &configuration::Configuration,
    apikey: &str,
    index_id: i64,
    document_id: i64,
) -> Result<i32, Error<DeleteDocumentByParameterApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;
    let p_index_id = index_id;
    let p_document_id = document_id;

    let uri_str = format!(
        "{}/api/v1/index/{index_id}/doc/{document_id}",
        configuration.base_path,
        index_id = p_index_id,
        document_id = p_document_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", p_apikey.to_string());

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteDocumentByParameterApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get document from index with index_id
pub async fn get_document_api(
    configuration: &configuration::Configuration,
    apikey: &str,
    index_id: i64,
    document_id: i64,
    get_document_request: models::GetDocumentRequest,
) -> Result<std::collections::HashMap<String, serde_json::Value>, Error<GetDocumentApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;
    let p_index_id = index_id;
    let p_document_id = document_id;
    let p_get_document_request = get_document_request;

    let uri_str = format!(
        "{}/api/v1/index/{index_id}/doc/{document_id}",
        configuration.base_path,
        index_id = p_index_id,
        document_id = p_document_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", p_apikey.to_string());
    req_builder = req_builder.json(&p_get_document_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<GetDocumentApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Index a JSON document or an array of JSON documents (bulk), each consisting of arbitrary key-value pairs to the index with the specified apikey and index_id, and return the number of indexed docs.  Index documents enables true real-time search (as opposed to near realtime.search): When in query_index the parameter `realtime` is set to `true` then indexed, but uncommitted documents are immediately included in the search results, without requiring a commit or refresh. Therefore a explicit commit_index is almost never required, as it is invoked automatically after 64k documents are indexed or on close_index for persistence.
pub async fn index_document_api(
    configuration: &configuration::Configuration,
    apikey: &str,
    index_id: i64,
    request_body: std::collections::HashMap<String, serde_json::Value>,
) -> Result<i32, Error<IndexDocumentApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;
    let p_index_id = index_id;
    let p_request_body = request_body;

    let uri_str = format!(
        "{}/api/v1/index/{index_id}/doc",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", p_apikey.to_string());
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<IndexDocumentApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Update a JSON document or an array of JSON documents (bulk), each consisting of arbitrary key-value pairs to the index with the specified apikey and index_id, and return the number of indexed docs.  Update document is a combination of delete_document and index_document. All current limitations of delete_document apply.  Update documents enables true real-time search (as opposed to near realtime.search): When in query_index the parameter `realtime` is set to `true` then indexed, but uncommitted documents are immediately included in the search results, without requiring a commit or refresh. Therefore a explicit commit_index is almost never required, as it is invoked automatically after 64k documents are indexed or on close_index for persistence.
pub async fn update_document_api(
    configuration: &configuration::Configuration,
    apikey: &str,
    index_id: i64,
    request_body: Vec<serde_json::Value>,
) -> Result<i32, Error<UpdateDocumentApiError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_apikey = apikey;
    let p_index_id = index_id;
    let p_request_body = request_body;

    let uri_str = format!(
        "{}/api/v1/index/{index_id}/doc",
        configuration.base_path,
        index_id = p_index_id
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    req_builder = req_builder.header("apikey", p_apikey.to_string());
    req_builder = req_builder.json(&p_request_body);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        serde_json::from_str(&content).map_err(Error::from)
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateDocumentApiError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
